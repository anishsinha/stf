{"version":3,"sources":["./node_modules/agm-direction/__ivy_ngcc__/fesm2015/agm-direction.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiF;AAChC;;AAEjD;AACA;AACA,cAAc,oCAAoC;AAClD;AACwC;AACJ;AACpC;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC;AACA,8BAA8B,0DAAY;AAC1C;AACA,kCAAkC,0DAAY;AAC9C;AACA,0BAA0B,0DAAY;AACtC;AACA,8BAA8B,0DAAY;AAC1C,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,CAAC,8DAA2B,GAAG;AAC7I,oBAAoB,+DAAwB,EAAE,8DAA8D,udAAud,YAAY,mKAAmK,aAAa,kEAA2B,GAAG;AAC7xB;AACA;AACA,KAAK,OAAO,8DAAoB;AAChC;AACA;AACA,cAAc,OAAO,mDAAK,EAAE;AAC5B,mBAAmB,OAAO,mDAAK,EAAE;AACjC,kBAAkB,OAAO,mDAAK,EAAE;AAChC,sBAAsB,OAAO,mDAAK,EAAE;AACpC,sBAAsB,OAAO,mDAAK,EAAE;AACpC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,yBAAyB,OAAO,mDAAK,EAAE;AACvC,gCAAgC,OAAO,mDAAK,EAAE;AAC9C,qBAAqB,OAAO,mDAAK,EAAE;AACnC,kBAAkB,OAAO,mDAAK,EAAE;AAChC,qBAAqB,OAAO,mDAAK,EAAE;AACnC,aAAa,OAAO,mDAAK,EAAE;AAC3B,qBAAqB,OAAO,mDAAK,EAAE;AACnC,kBAAkB,OAAO,mDAAK,EAAE;AAChC,eAAe,OAAO,mDAAK,EAAE;AAC7B,mBAAmB,OAAO,mDAAK,EAAE;AACjC,gBAAgB,OAAO,oDAAM,EAAE;AAC/B,kBAAkB,OAAO,oDAAM,EAAE;AACjC,sBAAsB,OAAO,oDAAM,EAAE;AACrC,cAAc,OAAO,oDAAM,EAAE;AAC7B,kBAAkB,OAAO,oDAAM,EAAE;AACjC,uBAAuB,OAAO,oDAAM,EAAE;AACtC;AACA,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,uDAAS;AACvB;AACA;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,OAAO,8DAA2B,EAAE,EAAE,EAAE,GAAG;AAC1E,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,oDAAM;AACxB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS;AACT,kBAAkB,mDAAK;AACvB,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAuB,EAAE,2BAA2B;AAC9E,0BAA0B,8DAAuB,EAAE,kDAAkD,wCAAwC,EAAE,iBAAiB;AAChK,cAAc,oDAAoD,gEAAyB,sBAAsB,wDAAwD,EAAE,EAAE;AAC7K,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,sDAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA,cAAc,oCAAoC;AAClD;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;;AAEA;AACA;AACA,cAAc,oCAAoC;AAClD;;AAEkD;;AAElD,yC","file":"default~buyer-dashboard-buyer-dashboard-module~buyer-wally-board-buyer-wally-board-module~carrier-ca~ed64cf5c-es2015.js","sourcesContent":["import { EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { GoogleMapsAPIWrapper } from '@agm/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@agm/core';\nclass AgmDirection {\n    /**\n     * @param {?} gmapsApi\n     */\n    constructor(gmapsApi) {\n        this.gmapsApi = gmapsApi;\n        // Options\n        this.travelMode = 'DRIVING';\n        this.transitOptions = undefined;\n        this.drivingOptions = undefined;\n        this.waypoints = [];\n        this.optimizeWaypoints = true;\n        this.provideRouteAlternatives = false;\n        this.avoidHighways = false;\n        this.avoidTolls = false;\n        // Remove or draw direction\n        this.visible = true;\n        // Direction change event handler\n        this.onChange = new EventEmitter();\n        // Direction response for the new request\n        this.onResponse = new EventEmitter();\n        // Send a custom infowindow\n        this.sendInfoWindow = new EventEmitter();\n        // Status of Directions Query (google.maps.DirectionsStatus.OVER_QUERY_LIMIT)\n        this.status = new EventEmitter();\n        // Marker drag event handler\n        this.originDrag = new EventEmitter();\n        this.destinationDrag = new EventEmitter();\n        this.directionsService = undefined;\n        this.directionsDisplay = undefined;\n        this.waypointsMarker = [];\n        // Use for visible flag\n        this.isFirstChange = true;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this.visible === true) {\n            this.directionDraw();\n        }\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    ngOnChanges(obj) {\n        /**\n         * When visible is false then remove the direction layer\n         */\n        if (!this.visible) {\n            try {\n                this.removeMarkers();\n                this.removeDirections();\n            }\n            catch (e) { }\n        }\n        else {\n            if (this.isFirstChange) {\n                /**\n                 * When visible is false at the first time\n                 */\n                if (typeof this.directionsDisplay === 'undefined') {\n                    this.directionDraw();\n                }\n                this.isFirstChange = false;\n                return;\n            }\n            /**\n             * When renderOptions are not first change then reset the display\n             */\n            if (typeof obj.renderOptions !== 'undefined') {\n                if (obj.renderOptions.firstChange === false) {\n                    this.removeMarkers();\n                    this.removeDirections();\n                }\n            }\n            this.directionDraw();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyMarkers();\n        this.removeDirections();\n    }\n    /**\n     * This event is fired when the user creating or updating this direction\n     * @return {?}\n     */\n    directionDraw() {\n        this.gmapsApi.getNativeMap().then((map) => {\n            if (typeof this.directionsDisplay === 'undefined') {\n                this.directionsDisplay = new google.maps.DirectionsRenderer(this.renderOptions);\n                this.directionsDisplay.setMap(map);\n                this.directionsDisplay.addListener('directions_changed', () => {\n                    this.onChange.emit(this.directionsDisplay.getDirections());\n                });\n            }\n            if (typeof this.directionsService === 'undefined') {\n                this.directionsService = new google.maps.DirectionsService;\n            }\n            if (typeof this.panel === 'undefined') {\n                this.directionsDisplay.setPanel(null);\n            }\n            else {\n                this.directionsDisplay.setPanel(this.panel);\n            }\n            // Render exist direction\n            if (typeof this.renderRoute === 'object' && this.renderRoute !== null) {\n                this.directionsDisplay.setDirections(this.renderRoute);\n                this.renderRoute = null; // or set undefined, ''\n            }\n            else {\n                // Request new direction\n                this.directionsService.route({\n                    origin: this.origin,\n                    destination: this.destination,\n                    travelMode: this.travelMode,\n                    transitOptions: this.transitOptions,\n                    drivingOptions: this.drivingOptions,\n                    waypoints: this.waypoints,\n                    optimizeWaypoints: this.optimizeWaypoints,\n                    provideRouteAlternatives: this.provideRouteAlternatives,\n                    avoidHighways: this.avoidHighways,\n                    avoidTolls: this.avoidTolls,\n                }, (response, status) => {\n                    this.onResponse.emit(response);\n                    // Emit Query Status\n                    this.status.emit(status);\n                    /**\n                     * DirectionsStatus\n                     * https://developers.google.com/maps/documentation/javascript/directions#DirectionsStatus\n                     */\n                    switch (status) {\n                        case 'OK':\n                            this.directionsDisplay.setDirections(response);\n                            /**\n                             * Emit The DirectionsResult Object\n                             * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults\n                             */\n                            // Custom Markers\n                            if (typeof this.markerOptions !== 'undefined') {\n                                this.destroyMarkers();\n                                // Set custom markers\n                                /** @type {?} */\n                                const _route = response.routes[0].legs[0];\n                                try {\n                                    // Origin Marker\n                                    if (typeof this.markerOptions.origin !== 'undefined') {\n                                        this.markerOptions.origin.map = map;\n                                        this.markerOptions.origin.position = _route.start_location;\n                                        this.originMarker = this.setMarker(map, this.originMarker, this.markerOptions.origin, _route.start_address);\n                                        if (this.markerOptions.origin.draggable) {\n                                            this.originMarker.addListener('dragend', () => {\n                                                this.origin = this.originMarker.position;\n                                                this.directionDraw();\n                                                this.originDrag.emit(this.origin);\n                                            });\n                                        }\n                                    }\n                                    // Destination Marker\n                                    if (typeof this.markerOptions.destination !== 'undefined') {\n                                        this.markerOptions.destination.map = map;\n                                        this.markerOptions.destination.position = _route.end_location;\n                                        this.destinationMarker = this.setMarker(map, this.destinationMarker, this.markerOptions.destination, _route.end_address);\n                                        if (this.markerOptions.destination.draggable) {\n                                            this.destinationMarker.addListener('dragend', () => {\n                                                this.destination = this.destinationMarker.position;\n                                                this.directionDraw();\n                                                this.destinationDrag.emit(this.destination);\n                                            });\n                                        }\n                                    }\n                                    // Waypoints Marker\n                                    if (typeof this.markerOptions.waypoints !== 'undefined') {\n                                        this.waypoints.forEach((waypoint, index) => {\n                                            // If waypoints are not array then set all the same\n                                            if (!Array.isArray(this.markerOptions.waypoints)) {\n                                                this.markerOptions.waypoints.map = map;\n                                                this.markerOptions.waypoints.position = _route.via_waypoints[index];\n                                                this.waypointsMarker.push(this.setMarker(map, waypoint, this.markerOptions.waypoints, _route.via_waypoints[index]));\n                                            }\n                                            else {\n                                                this.markerOptions.waypoints[index].map = map;\n                                                this.markerOptions.waypoints[index].position = _route.via_waypoints[index];\n                                                this.waypointsMarker.push(this.setMarker(map, waypoint, this.markerOptions.waypoints[index], _route.via_waypoints[index]));\n                                            }\n                                        }); // End forEach\n                                    }\n                                }\n                                catch (err) {\n                                    console.error('MarkerOptions error.', err);\n                                }\n                            }\n                            break;\n                        default:\n                            // console.warn(status);\n                            break;\n                    } // End switch\n                });\n            }\n        });\n    }\n    /**\n     * Custom Origin and Destination Icon\n     * \\@memberof AgmDirection\n     * @param {?} map map\n     * @param {?} marker marker\n     * @param {?} markerOpts properties\n     * @param {?} content marker's infowindow content\n     * @return {?} new marker\n     */\n    setMarker(map, marker, markerOpts, content) {\n        if (typeof this.infoWindow === 'undefined') {\n            this.infoWindow = new google.maps.InfoWindow({});\n            this.sendInfoWindow.emit(this.infoWindow);\n        }\n        marker = new google.maps.Marker(markerOpts);\n        // https://developers.google.com/maps/documentation/javascript/reference/marker?hl=zh-tw#MarkerOptions.clickable\n        if (marker.clickable) {\n            marker.addListener('click', () => {\n                /** @type {?} */\n                const infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;\n                this.infoWindow.setContent(infowindoContent);\n                this.infoWindow.open(map, marker);\n            });\n        }\n        return marker;\n    }\n    /**\n     * This event is fired when remove markers\n     * @return {?}\n     */\n    removeMarkers() {\n        if (typeof this.originMarker !== 'undefined') {\n            this.originMarker.setMap(null);\n        }\n        if (typeof this.destinationMarker !== 'undefined') {\n            this.destinationMarker.setMap(null);\n        }\n        this.waypointsMarker.forEach((w) => {\n            if (typeof w !== 'undefined') {\n                w.setMap(null);\n            }\n        });\n    }\n    /**\n     * This event is fired when remove directions\n     * @return {?}\n     */\n    removeDirections() {\n        if (this.directionsDisplay !== undefined) {\n            this.directionsDisplay.setPanel(null);\n            this.directionsDisplay.setMap(null);\n            this.directionsDisplay = undefined;\n        }\n    }\n    /**\n     * This event is fired when destroy markers\n     * @return {?}\n     */\n    destroyMarkers() {\n        // Remove origin markers\n        try {\n            if (typeof this.originMarker !== 'undefined') {\n                google.maps.event.clearListeners(this.originMarker, 'click');\n                if (this.markerOptions.origin.draggable) {\n                    google.maps.event.clearListeners(this.originMarker, 'dragend');\n                }\n            }\n            if (typeof this.destinationMarker !== 'undefined') {\n                google.maps.event.clearListeners(this.destinationMarker, 'click');\n                if (this.markerOptions.origin.draggable) {\n                    google.maps.event.clearListeners(this.destinationMarker, 'dragend');\n                }\n            }\n            this.waypointsMarker.forEach((w) => {\n                if (typeof w !== 'undefined') {\n                    google.maps.event.clearListeners(w, 'click');\n                }\n            });\n            this.removeMarkers();\n        }\n        catch (err) {\n            console.error('Can not reset custom marker.', err);\n        }\n    }\n}\nAgmDirection.ɵfac = function AgmDirection_Factory(t) { return new (t || AgmDirection)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.GoogleMapsAPIWrapper)); };\nAgmDirection.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AgmDirection, selectors: [[\"agm-direction\"]], inputs: { travelMode: \"travelMode\", transitOptions: \"transitOptions\", drivingOptions: \"drivingOptions\", waypoints: \"waypoints\", optimizeWaypoints: \"optimizeWaypoints\", provideRouteAlternatives: \"provideRouteAlternatives\", avoidHighways: \"avoidHighways\", avoidTolls: \"avoidTolls\", visible: \"visible\", renderRoute: \"renderRoute\", origin: \"origin\", destination: \"destination\", infoWindow: \"infoWindow\", renderOptions: \"renderOptions\", panel: \"panel\", markerOptions: \"markerOptions\" }, outputs: { onChange: \"onChange\", onResponse: \"onResponse\", sendInfoWindow: \"sendInfoWindow\", status: \"status\", originDrag: \"originDrag\", destinationDrag: \"destinationDrag\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nAgmDirection.ctorParameters = () => [\n    { type: GoogleMapsAPIWrapper }\n];\nAgmDirection.propDecorators = {\n    origin: [{ type: Input }],\n    destination: [{ type: Input }],\n    travelMode: [{ type: Input }],\n    transitOptions: [{ type: Input }],\n    drivingOptions: [{ type: Input }],\n    waypoints: [{ type: Input }],\n    optimizeWaypoints: [{ type: Input }],\n    provideRouteAlternatives: [{ type: Input }],\n    avoidHighways: [{ type: Input }],\n    avoidTolls: [{ type: Input }],\n    renderOptions: [{ type: Input }],\n    panel: [{ type: Input }],\n    markerOptions: [{ type: Input }],\n    infoWindow: [{ type: Input }],\n    visible: [{ type: Input }],\n    renderRoute: [{ type: Input }],\n    onChange: [{ type: Output }],\n    onResponse: [{ type: Output }],\n    sendInfoWindow: [{ type: Output }],\n    status: [{ type: Output }],\n    originDrag: [{ type: Output }],\n    destinationDrag: [{ type: Output }]\n};\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AgmDirection, [{\n        type: Directive,\n        args: [{\n                selector: 'agm-direction'\n            }]\n    }], function () { return [{ type: ɵngcc1.GoogleMapsAPIWrapper }]; }, { travelMode: [{\n            type: Input\n        }], transitOptions: [{\n            type: Input\n        }], drivingOptions: [{\n            type: Input\n        }], waypoints: [{\n            type: Input\n        }], optimizeWaypoints: [{\n            type: Input\n        }], provideRouteAlternatives: [{\n            type: Input\n        }], avoidHighways: [{\n            type: Input\n        }], avoidTolls: [{\n            type: Input\n        }], visible: [{\n            type: Input\n        }], onChange: [{\n            type: Output\n        }], onResponse: [{\n            type: Output\n        }], sendInfoWindow: [{\n            type: Output\n        }], status: [{\n            type: Output\n        }], originDrag: [{\n            type: Output\n        }], destinationDrag: [{\n            type: Output\n        }], renderRoute: [{\n            type: Input\n        }], origin: [{\n            type: Input\n        }], destination: [{\n            type: Input\n        }], infoWindow: [{\n            type: Input\n        }], renderOptions: [{\n            type: Input\n        }], panel: [{\n            type: Input\n        }], markerOptions: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass AgmDirectionModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        return {\n            ngModule: AgmDirectionModule,\n        };\n    }\n}\nAgmDirectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AgmDirectionModule });\nAgmDirectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AgmDirectionModule_Factory(t) { return new (t || AgmDirectionModule)(); }, imports: [[]] });\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AgmDirectionModule, { declarations: [AgmDirection], exports: [AgmDirection] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AgmDirectionModule, [{\n        type: NgModule,\n        args: [{\n                imports: [],\n                declarations: [\n                    AgmDirection,\n                ],\n                exports: [\n                    AgmDirection,\n                ]\n            }]\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { AgmDirectionModule, AgmDirection as ɵa };\n\n//# sourceMappingURL=agm-direction.js.map"],"sourceRoot":"webpack:///"}