// This sample is a C# ASP.NET web service application that 
// communicates with QuickBooks via QBWebConnector. The sample focuses 
// primarily on demonstrating how to setup all web service web methods 
// to run against QBWebConnector and does not focus on any particular 
// use case. For simplicity, it sends three request XMLs: 
// CustomerQuery, InvoiceQuery and BillQuery. 
//
// This sample assumes that you have configured IIS with ASP.NET and 
// have a functional system to deploy this web service sample. If you have 
// not yet configured ASP.NET with IIS, you may need to run the 
// following command from c:\windows\Microsoft.NET\Framework\
// your_asp_dot_net_version path: -
// aspnet_regiis /i 
// This will help avoid the occasional message from microsoft development 
// environment such as "VS.NET has detected that the specified web server 
// is not running ASP.NET version 1.1. You will be unable to run ASP.NET 
// web applications or services)". 

/*
 * Useful note about using OwnerID and FileID in a real-world application
 *  
 * As part of your QB Web Connector configuration (.QWC) file, you include
 * OwnerID and FileID. Following note on these two parameters may be useful. 
 * 
 * OwnerID -- this is a GUID that represents your application or suite of 
 * applications, if your application needs to store private data in the 
 * company file for one reason or another (one of the most common cases 
 * being to check if you have communicated with this company file before, 
 * and possibly some data about that communication) that private data will 
 * be visible to any application that knows the OwnerID.
 * 
 * FileID -- this is a GUID we stamp in the file on your behalf 
 * (using your OwnerID) as a private data extension to the "Company" object. 
 * It allows an application to verify that the company file it is exchanging 
 * data with is consistent over time (by doing a CompanyQuery with the field 
 * set appropriately and reading the DataExtRet values returned.
 * 
 * */


using SiteFuel.Exchange.Core.Resolver;
using SiteFuel.Exchange.Domain;
using SiteFuel.Exchange.Logger;
using SiteFuel.Exchange.Quickbooks.Models;
using SiteFuel.Exchange.Quickbooks.SharedEnums;
using SiteFuel.Exchange.Quickbooks.Workflows.Interfaces;
using SiteFuel.Exchange.ViewModels.AccountingEvent;
using SiteFuel.Exchange.ViewModels.Quickbooks;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Web.Services;

namespace SiteFuel.Exchange.Api.Mobile
{
    /// <summary>
    /// Web Service Namespace="http://developer.intuit.com/"
    /// Web Service Name="SFX_QBWebConnector"
    /// Web Service Description="SFX WebService in Exchange
    /// </summary>
    [WebService(
        Namespace = "http://developer.intuit.com/",
        Name = "SFX_QBWebConnector",
        Description = "SFX WebService in Exchange")]
    // Important Note:
    // You should keep the namespace as https://localhost:44366/ for all web 
    // services that communicates with QuickBooks Web Connector. 
    public class QBWebConnector : System.Web.Services.WebService
    {
        #region GlobalVariables

        private static IEnumerable<IResponseAdapter> responseAdapters;
        #endregion

        #region Constructor
        public QBWebConnector()
        {
            //CODEGEN: This call is required by the ASP.NET 
            //Web Services Designer
            InitializeComponent();
            // Initializing EventLog for logging
            //initEvLog();
        }
        #endregion

        #region AutoGeneratedMethods
        //Required by the Web Services Designer 
        private IContainer components = null;

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            if (responseAdapters == null)
            {

                responseAdapters = (from t in (AppDomain.CurrentDomain.GetAssemblies().
                                    SingleOrDefault(assembly => assembly.GetName().Name == "SiteFuel.Exchange.Quickbooks.Workflows").GetTypes())
                                    where t.GetInterfaces().Contains(typeof(IResponseAdapter))
                                    && t.GetConstructor(Type.EmptyTypes) != null
                                    select Activator.CreateInstance(t) as IResponseAdapter).ToList();
            }

            if (responseAdapters == null || !responseAdapters.Any())
            {
                // Log exception. No adapters were loaded by app domain
            }
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion

        #region WebMethods
        [WebMethod]
        /// <summary>
        /// WebMethod - getInteractiveURL()
        /// 
        /// Signature: public string getInteractiveURL(string wcTicket, string sessionID)
        ///
        /// IN: 
        /// string wcTicket
        /// string sessionID
        ///
        /// OUT: 
        /// URL string 
        /// Possible values: 
        /// URL to a website
        /// </summary>
        public string getInteractiveURL(string wcTicket, string sessionID)
        {
            return "";
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - interactiveRejected()
        /// 
        /// Signature: public string interactiveRejected(string wcTicket, string reason)
        ///
        /// IN: 
        /// string wcTicket
        /// string reason
        ///
        /// OUT: 
        /// string 
        /// </summary>
        public string interactiveRejected(string wcTicket, string reason)
        {
            return "";
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - interactiveDone()
        /// 
        /// Signature: public string interactiveDone(string wcTicket)
        ///
        /// IN: 
        /// string wcTicket
        ///
        /// OUT: 
        /// string 
        /// </summary>
        public string interactiveDone(string wcTicket)
        {
            return "";
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - serverVersion()
        /// To enable web service with its version number returned back to QBWC
        /// Signature: public string serverVersion()
        ///
        /// OUT: 
        /// string 
        /// Possible values: 
        /// Version string representing server version
        /// </summary>

        public string serverVersion()
        {
            string serverVersion = "2.0.0.1";
            string evLogTxt = "WebMethod: serverVersion() has been called " +
                "by QBWebconnector" + "\r\n\r\n";
            evLogTxt = evLogTxt + "No Parameters required.";
            evLogTxt = evLogTxt + "Returned: " + serverVersion;
            return serverVersion;
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - clientVersion()
        /// To enable web service with QBWC version control
        /// Signature: public string clientVersion(string strVersion)
        ///
        /// IN: 
        /// string strVersion
        ///
        /// OUT: 
        /// string errorOrWarning
        /// Possible values: 
        /// string retVal
        /// - NULL or <emptyString> = QBWC will let the web service update
        /// - "E:<any text>" = popup ERROR dialog with <any text> 
        ///					- abort update and force download of new QBWC.
        /// - "W:<any text>" = popup WARNING dialog with <any text> 
        ///					- choice to user, continue update or not.
        /// </summary>
        public string clientVersion(string strVersion)
        {
            string evLogTxt = "WebMethod: clientVersion() has been called " +
                "by QBWebconnector" + "\r\n\r\n";
            evLogTxt = evLogTxt + "Parameters received:\r\n";
            evLogTxt = evLogTxt + "string strVersion = " + strVersion + "\r\n";
            evLogTxt = evLogTxt + "\r\n";

            string retVal = null;
            double recommendedVersion = 1.5;
            double supportedMinVersion = 1.0;
            double suppliedVersion = Convert.ToDouble(this.parseForVersion(strVersion));
            evLogTxt = evLogTxt + "QBWebConnector version = " + strVersion + "\r\n";
            evLogTxt = evLogTxt + "Recommended Version = " + recommendedVersion.ToString() + "\r\n";
            evLogTxt = evLogTxt + "Supported Minimum Version = " + supportedMinVersion.ToString() + "\r\n";
            evLogTxt = evLogTxt + "SuppliedVersion = " + suppliedVersion.ToString() + "\r\n";
            if (suppliedVersion < recommendedVersion)
            {
                retVal = "W:We recommend that you upgrade your QBWebConnector";
            }
            else if (suppliedVersion < supportedMinVersion)
            {
                retVal = "E:You need to upgrade your QBWebConnector";
            }
            evLogTxt = evLogTxt + "\r\n";
            evLogTxt = evLogTxt + "Return values: " + "\r\n";
            evLogTxt = evLogTxt + "string retVal = " + retVal;
            logEvent(evLogTxt);
            return retVal;
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - authenticate()
        /// To verify username and password for the web connector that is trying to connect
        /// Signature: public string[] authenticate(string strUserName, string strPassword)
        /// 
        /// IN: 
        /// string strUserName 
        /// string strPassword
        ///
        /// OUT: 
        /// string[] authReturn
        /// Possible values: 
        /// string[0] = ticket
        /// string[1]
        /// - empty string = use current company file
        /// - "none" = no further request/no further action required
        /// - "nvu" = not valid user
        /// - any other string value = use this company file
        /// </summary>
        public string[] authenticate(string strUserName, string strPassword)
        {

            QbDomain qbDomain = new QbDomain();

            var companyProfile = qbDomain.ValidateQbUsernamePassword(strUserName, strPassword);
            string[] authReturn = new string[2];
            // Code below uses a random GUID to use as session ticket
            // An example of a GUID is {85B41BEE-5CD9-427a-A61B-83964F1EB426}
            authReturn[0] = companyProfile.Item1;
            if (string.IsNullOrEmpty(companyProfile.Item1))
            {
                authReturn[1] = "nvu";
            }
            else
            {
                var IsQbRequestAvailable = qbDomain.IsAnyQbRequestAvailable(companyProfile.Item1);
                if (!IsQbRequestAvailable)
                {
                    // You could also return "none" to indicate there is no work to do
                    authReturn[1] = "none";
                }
                else
                {
                    // An empty string for authReturn[1] means asking QBWebConnector 
                    // to connect to the company file that is currently openned in QB
                    authReturn[1] = companyProfile.Item2;
                }
            }

            // You could also return "none" to indicate there is no work to do
            // or a company filename in the format C:\full\path\to\company.qbw
            // based on your program logic and requirements.

            return authReturn;
        }

        [WebMethod(Description = "This web method facilitates web service to handle connection error between QuickBooks and QBWebConnector", EnableSession = true)]
        /// <summary>
        /// WebMethod - connectionError()
        /// To facilitate capturing of QuickBooks error and notifying it to web services
        /// Signature: public string connectionError (string ticket, string hresult, string message)
        ///
        /// IN: 
        /// string ticket = A GUID based ticket string to maintain identity of QBWebConnector 
        /// string hresult = An HRESULT value thrown by QuickBooks when trying to make connection
        /// string message = An error message corresponding to the HRESULT
        ///
        /// OUT:
        /// string retVal
        /// Possible values: 
        /// - done = no further action required from QBWebConnector
        /// - any other string value = use this name for company file
        /// </summary>
        public string connectionError(string ticket, string hresult, string message)
        {
            //if (Session["ce_counter"] == null)
            //{
            //    Session["ce_counter"] = 0;
            //}

            string evLogTxt = "connectionError()" + "\r\n\r\n";
            evLogTxt = evLogTxt + "Parameters received:\r\n";
            evLogTxt = evLogTxt + "string ticket = " + ticket + "\r\n";
            evLogTxt = evLogTxt + "string hresult = " + hresult + "\r\n";
            evLogTxt = evLogTxt + "string message = " + message + "\r\n";
            evLogTxt = evLogTxt + "\r\n";

            string retVal = null;
            // 0x80040400 - QuickBooks found an error when parsing the provided XML text stream. 
            const string QB_ERROR_WHEN_PARSING = "0x80040400";
            // 0x80040401 - Could not access QuickBooks.  
            const string QB_COULDNT_ACCESS_QB = "0x80040401";
            // 0x80040402 - Unexpected error. Check the qbsdklog.txt file for possible, additional information. 
            const string QB_UNEXPECTED_ERROR = "0x80040402";
            // Add more as you need...

            if (hresult.Trim().Equals(QB_ERROR_WHEN_PARSING))
            {
                evLogTxt = evLogTxt + "HRESULT = " + hresult + "\r\n";
                evLogTxt = evLogTxt + "Message = " + message + "\r\n";
                retVal = "DONE";
            }
            else if (hresult.Trim().Equals(QB_COULDNT_ACCESS_QB))
            {
                evLogTxt = evLogTxt + "HRESULT = " + hresult + "\r\n";
                evLogTxt = evLogTxt + "Message = " + message + "\r\n";
                retVal = "DONE";
            }
            else if (hresult.Trim().Equals(QB_UNEXPECTED_ERROR))
            {
                evLogTxt = evLogTxt + "HRESULT = " + hresult + "\r\n";
                evLogTxt = evLogTxt + "Message = " + message + "\r\n";
                retVal = "DONE";
            }
            else
            {
                // Depending on various hresults return different value 
                //if ((int)Session["ce_counter"] == 0)
                //{
                //    // Try again with this company file
                //    evLogTxt = evLogTxt + "HRESULT = " + hresult + "\r\n";
                //    evLogTxt = evLogTxt + "Message = " + message + "\r\n";
                //    evLogTxt = evLogTxt + "Sending empty company file to try again.";
                //    retVal = "";
                //}
                //else
                //{
                evLogTxt = evLogTxt + "HRESULT = " + hresult + "\r\n";
                evLogTxt = evLogTxt + "Message = " + message + "\r\n";
                evLogTxt = evLogTxt + "Sending DONE to stop.";
                retVal = "DONE";
                //}
            }
            evLogTxt = evLogTxt + "\r\n";
            evLogTxt = evLogTxt + "Return values: " + "\r\n";
            evLogTxt = evLogTxt + "string retVal = " + retVal + "\r\n";
            logEvent(evLogTxt, true);
            // Session["ce_counter"] = ((int)Session["ce_counter"]) + 1;
            return retVal;
        }



        [WebMethod(Description = "This web method facilitates web service to send request XML to QuickBooks via QBWebConnector", EnableSession = true)]
        /// <summary>
        /// WebMethod - sendRequestXML()
        /// Signature: public string sendRequestXML(string ticket, string strHCPResponse, string strCompanyFileName, 
        /// string Country, int qbXMLMajorVers, int qbXMLMinorVers)
        /// 
        /// IN: 
        /// int qbXMLMajorVers
        /// int qbXMLMinorVers
        /// string ticket
        /// string strHCPResponse 
        /// string strCompanyFileName 
        /// string Country
        /// int qbXMLMajorVers
        /// int qbXMLMinorVers
        ///
        /// OUT:
        /// string request
        /// Possible values: 
        /// - any_string = Request XML for QBWebConnector to process
        /// - "" = No more request XML 
        /// </summary>
        public string sendRequestXML(string ticket, string strHCPResponse, string strCompanyFileName,
                                     string qbXMLCountry, int qbXMLMajorVers, int qbXMLMinorVers)
        {
            QbDomain qbDomain = new QbDomain();

            var qbRequest = qbDomain.GetNextRequestByTokenAndUpdateStatus(ticket);
            if (qbRequest != null)
            {
                var template = new TemplateResponse();
                template.AddTemplate("RequestId", $"{qbRequest.WorkflowId}-{qbRequest.Id}");
                var resolvedTemplate = TemplateResolver.Resolve(qbRequest.QbXmlRq, template);

                var jsonMessage = $"{{strCompanyFileName: {strCompanyFileName ?? string.Empty }, strHCPResponse: {strHCPResponse ?? string.Empty }, qbXMLCountry: {qbXMLCountry ?? string.Empty }, qbXMLMajorVers: {qbXMLMajorVers}, qbXMLMinorVers: {qbXMLMinorVers}}}";
                qbDomain.SaveQbLogs(1, ticket, resolvedTemplate, null, null, jsonMessage);
                qbDomain.UpdateWorkflowStatus(qbRequest.WorkflowId, AccountingWorkflowStatus.Started);

                return resolvedTemplate;
            }

            return string.Empty;
        }

        [WebMethod(Description = "This web method facilitates web service to receive response XML from QuickBooks via QBWebConnector", EnableSession = true)]
        /// <summary>
        /// WebMethod - receiveResponseXML()
        /// Signature: public int receiveResponseXML(string ticket, string response, string hresult, string message)
        /// 
        /// IN: 
        /// string ticket
        /// string response
        /// string hresult
        /// string message
        ///
        /// OUT: 
        /// int retVal
        /// Greater than zero  = There are more request to send
        /// 100 = Done. no more request to send
        /// Less than zero  = Custom Error codes
        /// </summary>
        public int receiveResponseXML(string ticket, string response, string hresult, string message)
        {
            // Validate ticket and request Id of given company only
            var qbDomain = new QbDomain();
            var retVal = 1;
            try
            {
                qbDomain.SaveQbLogs(2, ticket, response, hresult, message);  // 2 for response
                if (string.IsNullOrWhiteSpace(response))
                {
                    qbDomain.UpdatePreviousRequestInQueueState(ticket);
                    retVal = 100;  // If no reponse is recieved don;t process more requests unless issue is resolved by QB
                    LogManager.Logger.WriteException("QBWebConnector", "receiveResponseXML", $"{ticket} {response} {hresult} {message}", new Exception());
                }

                var companyProfile = qbDomain.ValidateCompanyProfileByTicket(ticket);
                if (companyProfile == null)
                {
                    LogManager.Logger.WriteException("QBWebConnector", "receiveResponseXML", $"No Company file matched with this ticket {ticket}", new Exception());
                    LogManager.Logger.WriteDebug("QBWebConnector", "receiveResponseXML", $"No Company file matched with this ticket {ticket}");
                    return (int)ErrorCodes.InvalidTicket;
                }
                if (!string.IsNullOrEmpty(response) && string.IsNullOrEmpty(message))
                {
                    var strRequestId = ParseRequestId(response);
                    if (!string.IsNullOrWhiteSpace(strRequestId))
                    {
                        var requestIds = strRequestId.Split('-');
                        int workflowId = Int32.Parse(requestIds[0]);
                        int requestId = Int32.Parse(requestIds[1]);
                        var workflow = qbDomain.UpdateWorkflowWithResponse(companyProfile.CompanyId, workflowId, requestId, response);
                        if (workflow == null)
                        {
                            return (int)ErrorCodes.InvalidRequestIdForGivenTicket;
                        }
                        var request = workflow.QbRequests.FindLast(x => x.Id == requestId);
                        var totalCount = workflow.QbRequests.Count;
                        var pendingRequestCount = workflow.QbRequests.Count(x => x.Status == QbRequestStatus.NotReadToQueue || x.Status == QbRequestStatus.ReadyToQueue);
                        var requestType = request.QbXmlType;

                        var responseAdapter = responseAdapters.FirstOrDefault(x => x.Type == (QbXmlType)requestType);
                        var templateResponse = responseAdapter.ResolveResponse(response);
                        var pendingQbRequests = workflow.QbRequests.Where(x => x.Status == QbRequestStatus.NotReadToQueue).ToList();
                        if (!string.IsNullOrEmpty(templateResponse.ChainedAction))
                        {
                            var methodName = templateResponse.ChainedAction;
                            var method = GetType().GetMethod(methodName, BindingFlags.NonPublic | BindingFlags.Static);
                            method.Invoke(this, new object[] { companyProfile, qbDomain, workflowId, requestId, requestType, templateResponse, pendingQbRequests });
                        }

                        var postResult = DefaultPostResponseRecieve(qbDomain, workflowId, requestId, requestType, templateResponse, pendingQbRequests);
                        if (!postResult)
                        {
                            return -1; // Send error indicator to Quicbooks web connector
                        }
                        retVal = (totalCount - pendingRequestCount) * 100 / totalCount;
                        var workflowStatus = AccountingWorkflowStatus.Started;
                        if (templateResponse.Status == QbXmlStatus.Failed)
                        {
                            workflowStatus = AccountingWorkflowStatus.QbRequestFailed;
                        }

                        if (retVal == 100)
                        {
                            if (qbDomain.IsAnyQbRequestAvailable(ticket))
                            {
                                retVal = 1; // There are more workflow in pending state
                                            // Is current workflow in completed state
                                if (!qbDomain.IsAnyQbRequestAvailable(ticket, workflowId))
                                {
                                    workflowStatus = AccountingWorkflowStatus.Completed;
                                    if (!qbDomain.IsAnyNewQbRequestAvailableAfterThisWorkflow(ticket, workflowId))
                                    {
                                        retVal = 100;
                                    }
                                }
                            }
                            else
                            {
                                workflowStatus = AccountingWorkflowStatus.Completed;
                            }
                        }
                        qbDomain.UpdateWorkflowAndRequestStatus(workflowId, requestId, templateResponse.Status, workflowStatus);

                        if (templateResponse.Status == QbXmlStatus.Completed && responseAdapter.Type == QbXmlType.InvoiceAdd)
                        {
                            var invoiceNumber = templateResponse.Templates.FirstOrDefault(t => t.Key == TemplateParameter.InvoiceNumber).Value;
                            qbDomain.UpdateInvoiceNumber(request.EntityId, invoiceNumber);
                        }
                        else if (templateResponse.Status == QbXmlStatus.Completed && responseAdapter.Type == QbXmlType.ReceivePaymentQuery)
                        {
                            qbDomain.SaveReceivePaymentQueueMessage(requestId, workflowId, workflow.QbCompanyProfileId);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                LogManager.Logger.WriteException("QBWebConnector", "receiveResponseXML", ex.Message, ex);
                qbDomain.SaveQbLogs(3, ticket, response, hresult, ex.Message);  // 3 for exception
                retVal = -1;
            }
            return retVal;
        }        

        private static void SavePaymentTerms(QbCompanyProfile companyProfile, QbDomain qbDomain, int workflowId, int requestId, int requestType, TemplateResponse templateResponse, List<QbRequestViewModel> pendingQbRequests)
        {
            var terms = templateResponse.Templates.Select(x => new PaymentTerms
            {
                TermName = x.Key,
                TermDays = Convert.ToInt32(x.Value),
            }).ToList();
            qbDomain.SavePaymentTerms(companyProfile.CompanyId, terms);
        }

        private static bool DefaultPostResponseRecieve(QbDomain qbDomain, int workflowId, int requestId, int requestType, TemplateResponse templateResponse, List<QbRequestViewModel> pendingQbRequests)
        {
            var result = true;
            // 3170: The internals could not be locked.  They are in use by another user.
            // 3175: The transaction could not be locked.  It is in use by another user.
            if (templateResponse.StatusCode == (int)QResponseStatusCode.InternalsCouldNotBeLocked
                || templateResponse.StatusCode == (int)QResponseStatusCode.TheTransactionCouldNotBeLocked
                || templateResponse.StatusCode == (int)QResponseStatusCode.InternalError
                || templateResponse.StatusCode == (int)QResponseStatusCode.ListHasBeenModifiedByOtherUser)
            {
                qbDomain.UpdateFailedRequestAndEnqueue(requestId, workflowId);
                result = false;
            }
            else if (templateResponse.Templates.Any())
            {
                foreach (var qbReq in pendingQbRequests)
                {
                    var newRequestId = $"{qbReq.WorkflowId}-{qbReq.Id}";
                    var templateRespCopy = templateResponse.ShallowClone();
                    templateRespCopy.Templates.Add("RequestId", newRequestId);
                    qbReq.QbXmlRq = TemplateResolver.Resolve(qbReq.QbXmlRq, templateRespCopy);
                    qbReq.Status = TemplateResolver.IsXmlComplete(qbReq.QbXmlRq) ? QbRequestStatus.ReadyToQueue : qbReq.Status;
                    qbDomain.UpdateRequestWithStatus(qbReq.Id, qbReq.QbXmlRq, qbReq.Status);
                }
                UpdateEntityMapping(qbDomain, workflowId, requestId, requestType, templateResponse);
                result = true;
            }
            return result;
        }


        private static void UpdateEntityMapping(QbDomain qbDomain, int workflowId, int requestId, int requestType, TemplateResponse templateResponse)
        {
            if (requestType == (int)QbXmlType.InvoiceAdd)
            {
                var qbReferenceId = templateResponse.Templates.First().Value;
                var editSequence = templateResponse.Templates.Last().Value;
                qbDomain.UpdateQbInvoiceMapping(requestId, workflowId, qbReferenceId, editSequence);
            }
            else if (requestType == (int)QbXmlType.SalesOrderAdd || requestType == (int)QbXmlType.PurchaseOrderAdd || requestType == (int)QbXmlType.BillAdd)
            {
                var qbReferenceId = templateResponse.Templates.First().Value;
                var editSequence = templateResponse.Templates.Last().Value;
                qbDomain.UpdateQbEntityMapping(requestId, workflowId, qbReferenceId, editSequence);
            }
        }

        private string ParseRequestId(string response)
        {
            var result = string.Empty;
            try
            {
                var match = Regex.Match(response, "\\brequestID\\b=\"\\d+\\-\\d+\"");
                if (match.Success)
                {
                    var requestId = Regex.Match(match.Value, "\\d+\\-\\d+");
                    if (requestId.Success)
                    {
                        result = requestId.Value;
                    }
                }
            }
            catch
            {
                result = string.Empty;
            }
            return result;
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - getLastError()
        /// Signature: public string getLastError(string ticket)
        /// 
        /// IN:
        /// string ticket
        /// 
        /// OUT:
        /// string retVal
        /// Possible Values:
        /// Error message describing last web service error
        /// </summary>
        public string getLastError(string ticket)
        {
            string evLogTxt = "WebMethod: getLastError() has been called by QBWebconnector" + "\r\n\r\n";
            evLogTxt = evLogTxt + "Parameters received:\r\n";
            evLogTxt = evLogTxt + "string ticket = " + ticket + "\r\n";
            evLogTxt = evLogTxt + "\r\n";

            int errorCode = 0;
            string retVal = null;
            if (errorCode == -101)
            {
                retVal = "QuickBooks was not running!"; // This is just an example of custom user errors
            }
            else
            {
                QbDomain domain = new QbDomain();
                retVal = domain.GetLastErrorForTicket(ticket);
            }
            evLogTxt = evLogTxt + "\r\n";
            evLogTxt = evLogTxt + "Return values: " + "\r\n";
            evLogTxt = evLogTxt + "string retVal= " + retVal + "\r\n";
            logEvent(evLogTxt);
            return retVal;
        }

        [WebMethod]
        /// <summary>
        /// WebMethod - closeConnection()
        /// At the end of a successful update session, QBWebConnector will call this web method.
        /// Signature: public string closeConnection(string ticket)
        /// 
        /// IN:
        /// string ticket 
        /// 
        /// OUT:
        /// string closeConnection result 
        /// </summary>
        public string closeConnection(string ticket)
        {
            string evLogTxt = "closeConnection()" + "\r\n\r\n";
            evLogTxt = evLogTxt + "Parameters received:\r\n";
            evLogTxt = evLogTxt + "string ticket = " + ticket + "\r\n";
            evLogTxt = evLogTxt + "\r\n";
            string retVal = null;

            retVal = "OK";

            evLogTxt = evLogTxt + "\r\n";
            evLogTxt = evLogTxt + "Return values: " + "\r\n";
            evLogTxt = evLogTxt + "string retVal= " + retVal + "\r\n";
            logEvent(evLogTxt);
            return retVal;
        }
        #endregion

        #region UtilityMethods
        //private void initEvLog()
        //{
        //    try
        //    {
        //        string source = "QBWebConnector";
        //        if (!System.Diagnostics.EventLog.SourceExists(source))
        //        {
        //            System.Diagnostics.EventLog.CreateEventSource(source, "Application");
        //        }

        //        evLog.Source = source;
        //    }
        //    catch { };
        //    return;
        //}

        private void logEvent(string logText, bool isError = false)
        {
            try
            {
                if (isError)
                {
                    Logger.LogManager.Logger.WriteException("QBWebConnector", "log", logText, new Exception());
                }
                else
                {
                    Logger.LogManager.Logger.WriteDebug("QBWebConnector", "log", logText);
                }
            }
            catch { };
            return;
        }

        private string parseForVersion(string input)
        {
            // This method is created just to parse the first two version components
            // out of the standard four component version number:
            // <Major>.<Minor>.<Release>.<Build>
            // 
            // As long as you get the version in right format, you could use
            // any algorithm here. 
            string retVal = "";
            string major = "";
            string minor = "";
            Regex version = new Regex(@"^(?<major>\d+)\.(?<minor>\d+)(\.\w+){0,2}$", RegexOptions.Compiled);
            Match versionMatch = version.Match(input);
            if (versionMatch.Success)
            {
                major = versionMatch.Result("${major}");
                minor = versionMatch.Result("${minor}");
                retVal = major + "." + minor;
            }
            else
            {
                retVal = input;
            }
            return retVal;
        }
        #endregion
    } // class: QBWebConnector
} // namespace: QBWebConnector
